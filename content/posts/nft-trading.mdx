---
title: Pay your rent by coding an NFT trading bot
date: 28.8.2022
categories:
  - crypto
  - automation
  - proxy
  - typescript
banner: https://images.unsplash.com/photo-1640340434855-6084b1f4901c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1000&h=600&q=80
bannerAlt: Ethereum trading
bannerCredit: Photo by Dyllan Calluy (https://unsplash.com/@dylancalluy)
---

TODO: LIST OVER PARTS (w/ hypelinks?)

# Parts:

## How to lose 2 300 dollars in 1 minute because of a decimal point

## Norwegian NFT marketplace

## OpenSea developer discord support

## Introduction to Tristan

## Sander & I

### NFT Butler, NFT Wingman, NFT Handshake TODO:

## Moving hiatus

## The difference between 0.85 & 0.085 TODO:

## Going all in TODO:

## Rotating all the factors

## Hiring help

## Rinse & repeat

## The drop of Ethereum

## Summary TODO:

## How to lose 2 300 dollars in 1 minute.

TODO: SHORTEN THIS

I had an incredible day trading and I wanted to blow off some steam, so I made myself some food, opened a beer and put on a movie. During the movie I got an idea,
so I went to the office, made some changes to the bot and ran it. One minute later I saw some numbers that made my blood run cold.
I had missed a decimal point and bid 0.85 ETH instead of the intended 0.085 ETH on almost 500 NFTs. A very lucky individual whom was the first to see this naturally accepted
the idiodic bid and earned a nice profit amounting to more than the annual salary of the average citizen of India.

More people saw my bids and jumped at the opportunity to accept them, but since my wallet was already drained they were all (luckily) too late. This was early on in my journey and I had lost nearly all my starting capital.
But I am getting ahead of myself. Let's go back to the beginning.

## Norwegian NFT Marketplace

This all started how most good ideas come to life, by scratching an idea that seemed good in the beginning and pivoting to another.
A colleague and I decided to get into the Web3 space (this was back when Ethereum & NFTs were making headlines and popularity skyrocketed).

TODO: SHORT INTRODUCTION TO NFTs

We had the idea to create a Norwegian platform on which to trade NFTs. We both taugth ourselves the programming language Solidity which is predominately used to implement smart contracts on the Ethereum network.
After that I coded up a simple MVP for the frontend of the marketplace.

<!---
The idea was to leverage OpenSea's API & SDK on the backend, wrap our own backend around that and make the frontend easy to use and allow users to register and create crypto
wallets using Vipps and Firi (Norwegian systems) to more easily target a broader user-base. The MVP is still live,
though most of it does not work due to OpenSea making breaking changes to their APIs: https://torden.vercel.app/.
-->

We decided to integrate features from OpenSea (the largest marketplace for trading NFTs) to help kickstart the project. During development, I ran into some issues with the OpenSea's API,
so, naturally, I went to their Discord to ask for help from their developers. While I was corresponding with them, a message piqued my interest:

<div align="center">
  <img src="/images/article/nft-trading/piqued-interest.png" />
</div>

Why was this guy making so many bids at once? I had to know. I asked and the reply I got was the following:

<div align="center">
  <img src="/images/article/nft-trading/explanation.png" />
</div>

**The idea was ingenious as it was simple**; find a good collection of NFTs, bid a little under the floor price (the lowest 'buy now' price of that collection),
someone accepts your offer, you list the NFT for sale immediately and, once it sells, you pocket the change. Rinse and repeat.

Most people would look at the offer made and roll their eyes at it, but the 0.1% out there would see the offer as a possibility - a possibilty to sell a piece of digital art they sorely did not want anymore.
It was a numbers game. And the winner was the one who could code the bot with the fastest bid speed.

_The game was on. Thus began 4 months of work and countless hours of coding._

I still had the NFT platform to work on, but as time went on the trading bot became an obsession and my sole point of focus. I shared the idea with my business partner, and he was just as excited as me. That very weekend after many
hours of coding I had a working prototype. I began running it, and _it_. _was_. _*slow*_.

## How buying and selling digital art works on OpenSea

Before I can get to the nitty gritty details we have to know the basics of buying and selling digital art.
There are quite a few factors to consider: the bot bidding speed, the amount of concurrent outstanding bids, and, most cruicially, **the fees**.

> Digital art is not like physical art.

#### Let's do a little mental exercise:

We get into a time machine and travel to a not so distant past where Picasso was a starving artist still perfecting his work. He has just finished a fantastic painting, however, he needs to eat, yet he has no money.
He decides to sell this painting for $100 to a kind fellow on the street. Picasso isn't happy, but atleast he is fed.
We get into our time machine and travel back to the present and Picasso is one of the most renowed artists in human history. That very same paiting he sold for $100 to feed himself
has sold at auction for $10 000 000. How much of the money does Picasso get from the sale?

_None, because he is dead._ But were he alive today he would still not see any of the $9 999 900 the painting has appreciated for.

<div align="center">
  <img src="/images/article/nft-trading/picasso-sad.jpg" />
</div>

Poor Picasso.

NFTs are different, however. There is a royalty fee attached to the art which the artist decides when publishing. The fee can range from 0%, all the way up an extreme 10%.

Let's perform the same exercise as before, only now Picasso has released his paiting as an NFT and set a royalty fee of 10%. He would still only get $100 dollars on the inital sale, but years later,
when the painting is sold at auction he gets nearly a million dollars just from the royalties. This, including all the other subsequent times the piece changes hands after the initial sale,
would make Picasso an obscenely rich man.

<div align="center">
  <img src="/images/article/nft-trading/picasso-happy.jpg" />
</div>

But I am getting off topic.

This is not an article to persuade you to become an NFT artist so you can finally buy that yatcht and move to Monaco.
This is an article about writing code to automate buying NFTs so you can finally buy that yatcht and move to Monaco.

### Getting down into the nitty-gritty

The royalty fee is important to keep in mind when trading. If we buy an NFT for, say 1 ETH, and sell again for the same price, we won't break even, we'll be down 0.1 ETH.
OpenSea also takes a cut for facilitating the trade, which is a fixed 2.5%. In total we'll be down 0.125 ETH.
Which is why, when calculating the bid price, we want to bid below this, and a little extra. The little extra is our profit margin.

Below is the function I used to fetch information about the contract of the NFT and calculate the bid price dynamically to ensure a profitable trade, no matter the royalty fee:

<SyntaxHighlighter language="typescript">
  {`export default async function getCollectionData(
  slug: string, 
  profitPercentage: number
) {\n
  const {
    collection: { primary_asset_contracts, stats },
  } = await openseaFetch<CollectionType>({
    endpoint: OPENSEA_ENDPOINT.collection,
    pathParams: slug,
  });\n
  const { name, schema_name, address, seller_fee_basis_points } =
primary_asset_contracts[0];
  const { floor_price, count } = stats;\n
  log(´Successfully fetched contract {name}´);\n
  const feePercentage = seller_fee_basis_points / 10000;\n
  // -- Get bid price based on profit percentage of the sell price
  // BIDPRICE = SELL - (SELL * PROFITPERCENTAGE) - (SELL * FEE)
  const price =
    floor_price -
    (floor_price * profitPercentage) / 100 -
    floor_price * feePercentage;\n
  return {
    price: +price.toFixed(5),
    floorPrice: floor_price,
    feePercentage,
    count,
    schemaName: schema_name,
    tokenAddress: address,
  };
}`}
</SyntaxHighlighter>

There are many guards in place put there by OpenSea to limit how many bids you can place in a timeframe. Their API was intended to be used by normal people,
so they put up limitations to stop mass bidding. This, however, did not stop resourceful developers like us from finding genious solutions to circumvent these limitations.

### There are 4 main variables which limit our ability to rapidly bid on NFTs:

- The IP address of the client placing the bid.
- The API key which is used by the user to make the API call.
- The amount of Ethereum in the wallet making the bid on the NFT \* 10 000 (outstanding bids).
- Daily quota of Ethereum Node requests per day (Infura)

## Exceeding the API throttle limit:

If you're familiar with what a VPN is, then proxies shouldn't be be a hard concept to grasp. You can see it as a middleman between you and the internet.

Let's say you're back in first grade. You have a raging crush on a cute blonde girl in your class named Lily, and you want to send a love letter to her, confessing your feelings.

In classic first grade style, you're shy, and you don't want Lily to know that it's you who sent the letter, so you ask your bestest of friends (let's call him Dave) to deliver it for you.
Bare with me here, I assure you it will make sense. Dave gives the letter to Lily, and as she reads, she blushes and seems to be flattered, but since the letter wasn't signed,
she now thinks it was Dave who wrote it since he was the one who delivered it.

In this story, Dave is our Proxy and Lily is OpenSea's API. You make the request and give the proxy instructions on where the request should go.
The recipent of the request will think it is the proxy who made the request, thus allowing us to mask ourselves. This can then be scaled horizontally to make as many requests with as many proxies as you want in parallel,
making it look like different clients making the request at once.

Imagine an army of Daves going up to Lily to deliver a heartfelt love letter all at once. Below is a simple demonstration of how we can accomplish this in TypeScript:

#### Making a normal request:

<SyntaxHighlighter language="typescript">
  {`import fetch from "node-fetch";\n
const URL = 'https://httpbin.org/ip';\n
async function getOriginNoProxy() {
  const response = await fetch(URL, { agent });\n
  console.log(await response.json());
};\n
getOriginNoProxy();`}
</SyntaxHighlighter>

#### Result:

<SyntaxHighlighter language="javascript">
  {`{ origin: '47.216.122.92' }`}
</SyntaxHighlighter>

This API returns my IP address. You can try running the code yourself by pressing the button below. You'll get your current IP address, unmasked in its full glory.

<Button
  onClick={async () => {
    const response = await fetch("https://httpbin.org/ip");
    const data = await response.json();
    alert(JSON.stringify(data));
  }}
>
  Run the code above
</Button>

#### Using proxies:

<SyntaxHighlighter language="typescript">
  {`import fetch from "node-fetch";
import { HttpsProxyAgent } from "https-proxy-agent";\n
// This is a free proxy that I found. 
// It probably won't work for long after I post this article.
const proxy = {
  host: "130.41.41.175", 
  port: 8080,
};\n
const agent = new HttpsProxyAgent(proxy);\n
const URL = "https://httpbin.org/ip";\n
async function getOriginWithProxy() {
  const response = await fetch(URL, { agent });\n
  console.log(await response.json());
}\n
getOriginWithProxy();
`}
</SyntaxHighlighter>

#### Result:

<SyntaxHighlighter language="javascript">
  {`{ origin: '130.41.41.175' }`}
</SyntaxHighlighter>

As we can see here, the server I'm making a request to thinks the request is coming from the IP address I specified in the `httpsAgent`. Not my actual IP address.
But now we have basically accomplished what we had before, just more layers. The real power of proxies shows when we rotate them. Below we have an array of proxies and put the code above in a simple loop.

#### Rotating proxies:

<SyntaxHighlighter language="javascript">
  {`import { HttpsProxyAgent } from "https-proxy-agent";
import fetch from "node-fetch";\n
const proxies = [
  { host: "185.212.205.106", port: 59110 },
  { host: "185.212.205.231", port: 59110 },
  { host: "185.212.205.110", port: 59110 },
  { host: "185.212.205.232", port: 59110 },
  { host: "185.212.205.111", port: 59110 },
  { host: "185.212.205.230", port: 59110 },
  { host: "185.212.205.235", port: 59110 },
  { host: "185.212.205.114", port: 59110 },
  { host: "185.212.205.236", port: 59110 }
];\n
const URL = "https://httpbin.org/ip";\n
async function getOriginWithRotatingProxies() {
for (let x = 0; x < proxies.length; x++) {
  const { host, port } = proxies[x];\n
  const agent = new HttpsProxyAgent({ host, port });\n
  const response = await fetch(URL, { agent });\n
  console.log(await response.json());
}\n
getOriginWithRotatingProxies();`}
</SyntaxHighlighter>

#### Result:

<SyntaxHighlighter language="javascript">
  {`{ origin: '185.212.205.106' }
{ origin: '185.212.205.231' }
{ origin: '185.212.205.110' }
{ origin: '185.212.205.232' }
{ origin: '185.212.205.111' }
{ origin: '185.212.205.230' }
{ origin: '185.212.205.235' }
{ origin: '185.212.205.114' }
{ origin: '185.212.205.236' }`}
</SyntaxHighlighter>

That was pretty simple, wasn't it? But making requests to an API that just returns an IP address isn't very useful. This is where the [OpenSea SDK](https://github.com/ProjectOpenSea/opensea-js) comes in.

Finding where to implement the proxy logic was surprisingly easy. After digging for some time I finally found the private method _\_fetch_ that is utilized by all the functions of the SDK to call the API.
Bingo. Change the code here, change it for the whole project.

<SyntaxHighlighter language="typescript">
  {`import { HttpsProxyAgent } from "https-proxy-agent";
import { ProxyType } from "./data";\n
export default function dynamicProxyAgent(proxy: ProxyType) {
  return new HttpsProxyAgent({
    auth: "USERNAME:PASSWORD",
    host: proxy.host,
    port: proxy.port,
  });
}\n
...\n
private async _fetch(apiPath: string, opts: RequestInit = {}) {
  const apiBase = this.apiBaseUrl;
  const apiKey = this.apiKey;
  const finalUrl = apiBase + apiPath;\n
  const finalOpts: RequestInit = {
    ...opts,
    headers: {
      ...(apiKey ? { "X-API-KEY": apiKey } : {}),
      ...(opts.headers || {}),
    },
    // This is where I implemented the proxy logic
    agent: dynamicProxyAgent(
      proxies[Math.floor(Math.random() * proxies.length)]
    ),
  };\n
  this.logger(
    ´Sending request: {finalUrl} {JSON.stringify(finalOpts).substr(
    0,
    100
  )}...´
  );\n
  const fetchResponse = await fetch(finalUrl, finalOpts);\n
  return await this._handleApiResponse(fetchResponse);
}\n
...`}
</SyntaxHighlighter>

> Note:
> A big caveat to proxies is that the proxy provider can see all the traffic routed through their service. This can be a huge security concern. There are both free proxies and paid proxies.
> Like all things in life: if it's free, you're the product.

The company behind the free proxies aren't just nice people who want to make the internet a safer place. They use the traffic routed through their service and sell the data.
I would never recommend using a free proxy when making requests containing sensitive information.

Making bids in OpenSea specifies a private API key, your ethereum wallet address, your mnemonic phrase.
The type of stuff you _do not_ want other people to see. Therefore, should you try this yourself, you should definitely look into using a paid service.

I searched around a lot and tried a lot of different services. I eventually landed on an unnamed shoddy service due to a lack of better alternatives.
What I eventually found is that it is a Russian company behind this service, and keep in mind, this when the Ukrainian
war had just started.

While using their service it crashed and it was down for a few days.
I contacted their support and they, in turn, directly told me it was due to the west sanctioning their country. They fixed the issue and offered me a free coupon. I, naturally, accepted.

## The OpenSea API keys

If you're not familiar with API keys, think of them as credentials to your Netflix account. If you don't have your password, you're not watching that last season of Grey's Anatomy.

When it comes to API keys on OpenSea, the development team has a full monopoly over who gets keys and who doesn't. You'll to [fill out a form](https://docs.opensea.io/reference/request-an-api-key) and wait for approval.
Most people never get their API key. I was lucky enough to get one, however the rate limit of one key is _4 requests per second_. That's abysmally low.

<div align="center">
  <img src="/images/article/nft-trading/rookie-numbers.gif" />
</div>

Considering that completing a single bid takes a total of 4 API calls, if I wanted to do a full sweep of a usual collection of **10 000 NFTs**, it would take. Drum roll... you guessed it!
10 000 seconds or **2 hours and 46 minutes**.

Remember, this is a numbers game, the more nets you throw out into the ocean, the more fish you're going to catch.
Spending 3 hours to throw out 10 000 nets may sound like a lot, but in the world of fishing for digital art this gives us a very low probability of catching anything.

**We can do better than that.**

"But how?" I hear you say. "OpenSea has a strict limit of 1 key per developer and currently nobody is getting any keys." You worry not, my sweet summer child,
for this is where the careless users of the open-source community comes in. See, people, by nature, are messy, especially when it comes to storing sensitive credentials.

If you go to [GitHub and search OPENSEA_API_KEY](https://github.com/search?p=1&q=OPENSEA_API_KEY&type=Code) you get over 80 pages of open-source code
where people are using their API keys. Some have done a good job of keeping their API keys secret, others, not so much. Write a quick web scraper to go over each page,
find the hard-coded API keys, validate them by making a redundant API call to OpenSea and violà! We now have a lot of API keys to play around with.

When I did this I got a total of 17 keys. This includes that some keys that I got from other botters who were in desperate need of the rotating proxy logic. And here I am giving it away for free.

## The outstanding bid limit

The easiest one is by far the bid limit. OpenSea set a hard cap on the bids each wallet can have active at once. This is calculated using a dead simple formula:

<mark>wallet funds * 10000 > total outstanding bid amount</mark>

What does this mean? Let's put it into practice.

If we have a crypto wallet containing 1 ETH, we would have a max outstanding bid amout of 10 000 ETH. If we now run our bot and place bids with a price of 1 ETH on each NFT we would be able to bid on 10 000 NFTs.
The way to increase this number is obvious: either decrease bid price, or put more money in your wallet.

This limitation creates a snow ball effect; the more you profit; the more you can bid; the more you can profit. It is cash-positive feedback loop.

## The daily quota of Ethereum Node requests per day

So far we've gone over rotating proxies, API keys and the outstanding bid limit.

Last, but not least, we have the nodes you have to use to talk to the Ethereum network. A single node contains the whole network and it is replicated all across other nodes in the word.

If there is an update to our Node, the other Nodes around the world verify and update. If there is a update on one of the countless other Nodes in the world, our Node verifies and updates.
Keep in mind, this is a huge simplification of how the Ethereum network actually works. But in broad strokes this explanation will suffice.

In any case, setting up a node for yourself is expensive and hard (unless your name is Vitalik). A much easier option is to use a provider such as Infura, and use their API.
Their service is free up to 100 000 requests per day. When scaling up my bot I quickly hit this limit.

> How should I solve this issue?

Every new user on Infura's platform gets a free 100 000 requests per day. If you can make more accounts, you can essentially get more API keys, each with a daily limit of 100k requests.

I used a temporary email service and managed to make a couple of fake accounts all with their own daily quotas. Nice! Now to make many more. I tried automating it, but captchas, anti-bot measures,
making fake emails and saving the generated API key in a database made it a troublesome task, so what to do? I could spend hours doing it myself, and I did for a little while.
But that kind of boring work made it feel like I was slowly dying inside. So doing it myself is off the table, and automating it is not worth the development cost. What now?

I went into a Swedish discord channel and posted the following:

<div align="center">
  <img src="/images/article/nft-trading/hiring.png" />
</div>

I got a lot of DMs. In retrospect I think I might have overpaid, but I felt the work was so tedious and boring that nobody would do it for less. In any case,
I found a good candidate, and they got to work creating fake accounts and storing the API key. At the end I had a total of **220 keys** which allowed my bot to make a total of **2 200 000 requests per day**. This was exactly what I needed.

TODO: WRITE MORE ABOUT THE CODE ITSELF

With all these in place and some fine tuning to the code, which I did over several months I ended up bidding on 850 000 NFTs per day. That's a total of 3.4 million API requests.
All routed through some datacenter in Spain coming directly from my server at home.

## In conclusion

The way my journey is detailed in this article makes it sound like the road was clear cut: it was not. I made a lot of mistakes, learned and grew. I was constantly optimizing the code and the infrastructure on which it ran.
The bot started from around 22 to a whopping 600 bids per minute or 850 000 bids per day.

Eventually the price of Ethereum dropped heavily, the hype for NFTs slowly fizzled out and I started at a new company, which took up a significant portion of my time and energy, so I stopped.
