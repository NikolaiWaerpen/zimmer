---
title: How I paid my rent by trading NFTs with code
date: 28.8.2022
categories:
  - crypto
  - automation
  - proxy
  - typescript
banner: https://images.unsplash.com/photo-1640340434855-6084b1f4901c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1664&q=80
bannerAlt: Ethereum trading
bannerCredit: Photo by Dyllan Calluy (https://unsplash.com/@dylancalluy)
---

# Parts:

## How to lose 2 300 dollars in 1 minute because of a decimal point

## Norwegian NFT marketplace

## OpenSea developer discord support

## Introduction to Tristan

## Sander & I

### NFT Butler, NFT Wingman, NFT Handshake

## Moving hiatus

## Going all in

## The difference between 0.85 & 0.085

## Rotating all the factors

## Hiring help

## Rinse & repeat

## The drop of Ethereum

## Summary

## How to lose 2 300 dollars in 1 minute.

I had an incredible day trading and I wanted to blow off some steam, so I made myself some food, opened a beer and put on a movie. During the movie I got an idea, so I went to the office, made some changes to the bot and ran it.
One minute later I saw some numbers that made my blood run cold. I had missed a decimal point and bid 0.85 ETH instead of the intended 0.085 ETH on almost 500 NFTs.
A very lucky individual whom was the first to see this naturally accepted the idiodic bid and earned a nice profit amounting to more than the annual salary of the average citizen of India.

I had lost nearly all my starting capital. More people saw my bids and jumped at the opportunity to accept them, but since my wallet was already drained they were all (luckily) too late.
But I am getting ahead of myself. Let's go back to the beginning.

## Norwegian NFT Marketplace

This all started how most good ideas come to life, by scratching an idea that seemed good in the beginning and pivoting to another. A colleague and I decided to get into the Web3 space (this was back when Ethereum & NFTs were making headlines and popularity skyrocketed).

We had the idea to create a Norwegian platform on which to trade NFTs. We both taugth ourselves the programming language Solidity which is predominately used to implement smart contracts on the Ethereum network.
After that I coded up a simple MVP for the frontend of the marketplace.

The idea was to leverage OpenSea's API & SDK on the backend, wrap our own backend around that and make the frontend easy to use and allow users to register and create crypto wallets using Vipps and Firi (Norwegian systems) to more easily target a broader user-base.
The MVP is still live, though most of it does not work due to OpenSea making breaking changes to their APIs: https://torden.vercel.app/.

During development, I ran into some issues with OpenSea's platform, so I naturally went to their Discord to get help from some of their devs. While I was corresponding with them, a messages piqued my interest:

<div align="center">
  <img src="/images/article/nft-trading/piqued-interest.png" />
</div>

Why was this guy making so many bids at once?

So I asked, and he replied:

<div align="center">
  <img src="/images/article/nft-trading/explanation.png" />
</div>

The idea was as ingenious as it was simple: find a good collection of NFTs. Bid a little under their floor price (the lowest price you could buy one for immediately).
If someone accepts your offer, you list the NFT for sale immediately and, once it sells, pocket the change. Rinse and repeat.

Most people would look at the offer and roll their eyes at it, but the 0.1% out there would see the offer as a possibility - a possibilty to sell a piece of digital art they sorely did not want anymore.
It was a numbers game. And the winner was the one who could code the fastest bot.

Thus began 4 months of work and hundreds of hours coding.

I still had the NFT platform to work on, but as time went on the trading bot became an obsession and my sole point of focus. I shared the idea with my business partner, and he was just as excited as me. That very weekend after many
hours of coding I had a working prototype. I began running it, and _it_. _was_. _*slow*_.

## How buying and selling digital art works on OpenSea

There are quite a few factors to consider. The biggest of which is the bot speed, the amount of outstanding bids, and, most cruicially, the fees.

See, digital art is not like physical art. Let's do a little mental exercise:
We get into a time machine and travel to a not so distant past where Picasso was a starving artist still perfecting his work. He has just finished a fantastic painting, however he needs to eat, and he has no money.
He decides to sell this painting for $100. He isn't happy, but atleast it feeds him for a couple of days.
We get into our time machine and travel to the present and Picasso is one of the most renowed artists in human history. Now that very same paiting has sold at auction for $10 000 000. How much of the money does Picasso get from the sale?

None, because he is dead. But were he alive today he would still not see any of the $9 999 900 the painting has appreciated for.

<div align="center">
  <img src="/images/article/nft-trading/picasso-sad.jpg" />
</div>

Poor Picasso.

NFTs are different, however. There is a royalty fee attached to the art which the artist decides when publishing. The fee can range from 0%, all the way up an extreme 10%.

Let's perform the same exercise as before, only now Picasso has released his paiting as an NFT and set a royalty fee of 10%. He would still only get $100 dollars on the inital sale, but years later,
when the paiting is sold at auction he gets nearly a million dollars just from royalties, and all the other subsequent times the piece changes hands after the initial sale.

<div align="center">
  <img src="/images/article/nft-trading/picasso-happy.jpg" />
</div>

But I am getting off topic. This is not an article attempting to persuading you to become an NFT artist so you can finally buy that yatcht and move to Monacco.
This article is about writing code to automate buying NFTs so you can finally buy that yatcht and move to Monacco.

The royalty fee is important to keep in mind when trading. If we buy an NFT for, say 1 ETH, and sell again for the same price, we won't break even, we'll be down 0.1 ETH.
OpenSea also takes a cut for facilitating the trade,which is a fixed 2.5%. In total we'll be down 0.125 ETH.
That is why, when calculating the bid price, we want to bid below this, and a little extra. This is little extra amounts to our profit margin.

Below is the function I used to fetch information about the contract of the NFT and calculate the bid price dynamically to ensure a profitable trade:

<SyntaxHighlighter language="typescript">
  {`export default async function getCollectionData(
  slug: string, 
  profitPercentage: number
) {\n
  const {
    collection: { primary_asset_contracts, stats },
  } = await openseaFetch<CollectionType>({
    endpoint: OPENSEA_ENDPOINT.collection,
    pathParams: slug,
  });\n
  const { name, schema_name, address, seller_fee_basis_points } =
primary_asset_contracts[0];
  const { floor_price, count } = stats;\n
  log(´Successfully fetched contract {name}´);\n
  const feePercentage = seller_fee_basis_points / 10000;\n
  // -- Get bid price based on profit percentage of the sell price
  // BIDPRICE = SELL - (SELL * PROFITPERCENTAGE) - (SELL * FEE)
  const price =
    floor_price -
    (floor_price * profitPercentage) / 100 -
    floor_price * feePercentage;\n
  return {
    price: +price.toFixed(5),
    floorPrice: floor_price,
    feePercentage,
    count,
    schemaName: schema_name,
    tokenAddress: address,
  };
}`}
</SyntaxHighlighter>

There are many variables that limit how many bids you can place a minute. This API was intended to be used by normal people, so OpenSea put up limitations to stop people from mass bidding.
This, however, did not stop resourceful people from finding genious solutions to circumvent these limitations.

### There are 4 main variables which limit our ability to rapidly bid on NFTs:

- The IP address of the client placing the bid.
- The API key which is used by the user to make the API call.
- The amount of Ethereum in the wallet making the bid on the NFT \* 10 000 (for outstanding bids).
- Node requests per day (Infura)

First, the rotating proxies:
If you're familiar with VPNs then proxies shouldn't be be hard to grasp. It's basically a middleman between you and the internet. You specify the IP and the port of the proxy (and perhaps some authentication if it is a paid service) and then you can make requests like normal,
but all your traffic will be routed through the IP you specificed. This essentialy allows you to mask your IP address, and thereby make it look like someone else is making the request. Rotating proxies is just what the name implies; you specify a list of proxies and then you rotate through them, essentially
making it look like a new client is making the request every time. Below I'll show a simple demonstration on how this can be accomplished in TypeScript:

# Exceeding the API throttle limit

### Making a normal request:

<SyntaxHighlighter language="typescript">
  {`import fetch from "node-fetch";\n
const URL = 'https://httpbin.org/ip';\n
async function getOriginNoProxy() {
  const response = await fetch(URL, { agent });\n
  console.log(await response.json());
};\n
getOriginNoProxy();`}
</SyntaxHighlighter>

#### Result:

<SyntaxHighlighter language="javascript">
  {`{ origin: '47.216.122.92' }`}
</SyntaxHighlighter>

This API returns my IP address. You can try running the code yourself by pressing the button below. You'll get your current IP address, unmasked in its full glory.

<Button
  onClick={async () => {
    const response = await fetch("https://httpbin.org/ip");
    const data = await response.json();
    alert(JSON.stringify(data));
  }}
>
  Run the code above
</Button>

### Using proxies:

<SyntaxHighlighter language="typescript">
  {`import fetch from "node-fetch";
import { HttpsProxyAgent } from "https-proxy-agent";\n
// This is a free proxy that I found. 
// It probably won't work for long after I post this article.
const proxy = {
  host: "130.41.41.175", 
  port: 8080,
};\n
const agent = new HttpsProxyAgent(proxy);\n
const URL = "https://httpbin.org/ip";\n
async function getOriginWithProxy() {
  const response = await fetch(URL, { agent });\n
  console.log(await response.json());
}\n
getOriginWithProxy();
`}
</SyntaxHighlighter>

#### Result:

<SyntaxHighlighter language="javascript">
  {`{ origin: '130.41.41.175' }`}
</SyntaxHighlighter>

As we can see here, the server I'm making a request to thinks the request is coming from the IP address I specified in the `httpsAgent`. Then, to make this rotating, we would have an array of proxies and put the code in a simple for loop.

### Rotating proxies:

<SyntaxHighlighter language="javascript">
  {`import { HttpsProxyAgent } from "https-proxy-agent";
import fetch from "node-fetch";\n
const proxies = [
  { host: "185.212.205.106", port: 59110 },
  { host: "185.212.205.231", port: 59110 },
  { host: "185.212.205.110", port: 59110 },
  { host: "185.212.205.232", port: 59110 },
  { host: "185.212.205.111", port: 59110 },
  { host: "185.212.205.230", port: 59110 },
  { host: "185.212.205.235", port: 59110 },
  { host: "185.212.205.114", port: 59110 },
  { host: "185.212.205.236", port: 59110 }
];\n
const URL = "https://httpbin.org/ip";\n
async function getOriginWithRotatingProxies() {
for (let x = 0; x < proxies.length; x++) {
  const { host, port } = proxies[x];\n
  const agent = new HttpsProxyAgent({
    host,
    port,
  });\n
  const response = await fetch(URL, { agent });\n
  console.log(await response.json());
}\n
getOriginWithRotatingProxies();`}
</SyntaxHighlighter>

#### Result:

<SyntaxHighlighter language="javascript">
  {`{ origin: '185.212.205.106' },
{ origin: '185.212.205.231' },
{ origin: '185.212.205.110' },
{ origin: '185.212.205.232' },
{ origin: '185.212.205.111' },
{ origin: '185.212.205.230' },
{ origin: '185.212.205.235' },
{ origin: '185.212.205.114' },
{ origin: '185.212.205.236' }`}
</SyntaxHighlighter>

That was pretty simple, wasn't it? But making requests to an API that just returns an IP address isn't very useful. This is where the [OpenSea SDK](https://github.com/ProjectOpenSea/opensea-js) comes in.

Finding where to implement the proxy logic was surprisingly easy. Just skimming through some undocumented and messy backend code. After digging for some time I finally found the private method _\_fetch_ that is utilized by all the functions of the SDK to call the API.
Bingo. Change the code here, change it for the whole project.

<SyntaxHighlighter language="typescript">
  {`import { HttpsProxyAgent } from "https-proxy-agent";
import { ProxyType } from "./data";\n
export default function dynamicProxyAgent(proxy: ProxyType) {
  return new HttpsProxyAgent({
    auth: "USERNAME:PASSWORD",
    host: proxy.host,
    port: proxy.port,
  });
}\n
private async _fetch(apiPath: string, opts: RequestInit = {}) {
  const apiBase = this.apiBaseUrl;
  const apiKey = this.apiKey;
  const finalUrl = apiBase + apiPath;\n
  const finalOpts: RequestInit = {
    ...opts,
    headers: {
      ...(apiKey ? { "X-API-KEY": apiKey } : {}),
      ...(opts.headers || {}),
    },
    // This is where I implemented the proxy logic
    agent: dynamicProxyAgent(
      proxies[Math.floor(Math.random() * proxies.length)]
    ),
  };\n
  this.logger(
    ´Sending request: {finalUrl} {JSON.stringify(finalOpts).substr(
    0,
    100
  )}...´
  );\n
  const fetchResponse = await fetch(finalUrl, finalOpts);\n
  return await this._handleApiResponse(fetchResponse);
}`}
</SyntaxHighlighter>

A big caveat to proxies is that the proxy provider can see all the trafffic routed through their service. This can be a huge security concern. There are both free proxies and paid proxies.
Like all things in life: if it's free, you're the product. The company behind the free proxies aren't just nice people who want to make the internet a better place. They use the traffic routed through their service and sell the data.
I would never recommend using a free proxy when making requests containing sensitive information. Making bids in OpenSea specifies a private API key, you ethereum wallet address, your mnemonic phrase.
The type of stuff you _do not_ want other people to see. Therefore, should you try this yourself, you should definitely look into using a paid service.

I searched around a lot and tried a lot of different services. I eventually landed on this service: https://proxy-seller.com due to a lack of better alternatives. What I eventually found out is that it is a Russian company behind this service, and keep in mind, this when the Ukrainian
war had just started. There was once an outage where their service was down for a few days. I contacted their support and they said they were resolving the issue (in very broken english) and offered me a free coupon. I am not certain, but I am pretty sure this had something to do with Russia
coming under a lot of sanctions from other countries.

# The API key which is used by the user to make the API call

When it comes to API keys the OpenSea dev team has full monopoly over who gets keys and who doesn't. You have to fill out a form and wait for approval. Most people never got their API key. I was lucky enough to get one, however the rate limit is 4 requests per seconds. That's is abysmally low.

<div align="center">
  <img src="/images/article/nft-trading/rookie-numbers.gif" />
</div>

Considering that each bid makes a total of 4 API calls and if I wanted to do a full sweep of a usual collection of **10 000 NFTs** it would take me. Drum roll... you guessed it! 10 000 seconds or **2 hours and 46 minutes**.

We can do better than that.

But how? OpenSea has a strict limit of 1 key per developer and currently nobody is getting any keys. This is where the careless users of GitHub comes in. See, people are messy, especially when it comes to sensitive credentials.
If you go to [GitHub right now and search OPENSEA_API_KEY](https://github.com/search?p=1&q=OPENSEA_API_KEY&type=Code) you get over 80 pages of open-source code where people are using their API keys.

Some have done a good job of keeping their API keys secret, others have not. Write a quick web scraper to go over each page, find the hard-coded API keys, test them and violà! You now have a lot of API keys to play around with. When I did this I got a total of 20 keys.

Next up: The outstanding bid limit. OpenSea set a hard cap on the bids you can have active at once. This was calculated using a simple formula:
wallet funds \* 10000 > total outstanding bid amount

What does this mean? Let's put it into practice.

Say we have a crypto wallet with 1 ETH we would have a max outstanding bid amout of 10 000 ETH. If we make bids with a price of 1 ETH we would be able to bid on 10 000 NFTs. The way to increase this number is pretty obvious: either decrease bid price, or put more money in your wallet.

Last, but not least, to talk to the Ethereum network you need a node. A node contains the whole Ethereum network and it is replicated all across other nodes in the word. If there is an update our Node, the other Nodes verify and update.
If there is a update on countless other Nodes in the world, our Node verifies and updates. Keep in mind, this is a huge simplification of how the Ethereum network actually works.

In any case, setting up a node for yourself is expensive and hard. A much easier option is to use a provider such as Infura to use their API. Their service is free up to 100 000 requests per day. I quickly hit this limit.

See, every new user on Infuras platform gets a free 100 000 requests per day. If you can make more accounts, you can get more API keys, each with a daily limit of 100 000.

I tried automating it, but captchas, generating fake emails and saving the generated API key in a database made it a troublesome task, so what to do?

I went into a random Swedish discord channel and posted the following:

<div align="center">
  <img src="/images/article/nft-trading/hiring.png" />
</div>

Someone quickly DM'ed me. I found a good candidate, and they got to work creating fake accounts. At the end I had a total of 220 API keys which allowed my bot to make a total of 2 200 000 requests per day. This was exactly what I needed.

WRITE MORE ABOUT THE CODE ITSELF

With all these in place and some fine tuning to the code, which I did over several months I ended up bidding on 850 000 NFTs per day. That's a total of 3.4 million API requests. All routed through some datacenter in Spain coming directly from my server.

# Summary

The way my journey is detailed in this article makes it sound like the road was clear cut: it was not. I made a lot of mistakes, learned and grew. I was constantly optimizing the code and the infrastructure on which it ran.
The bot started from around 22 to a whopping 600 bids per minute or 850 000 bids per day.
